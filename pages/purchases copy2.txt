from dash import html, dcc, dash_table, Input, Output, State, no_update, register_page, callback
import pandas as pd
from pdash.database import update_user_purchase, fetch_user_purchases
from flask import session

register_page(__name__, path="/purchases")

def serve_layout():
    user_id = session.get("user_id")
    if not user_id:
        return html.Div("Пожалуйста, войдите в систему.")

    # Загрузка данных
    df = fetch_user_purchases(user_id)

    # Форматируем дату для DatePicker и ISO‑строку для timestamp
    df["date"] = pd.to_datetime(df["date"]).dt.strftime("%Y-%m-%d")
    df["ts"]   = pd.to_datetime(df["ts"]).dt.strftime("%Y-%m-%dT%H:%M:%SZ")

    return html.Div([
        dash_table.DataTable(
            id="purchases-table",
            data=df.to_dict("records"),
            columns=[
                {"name": "ID",           "id": "id",          "hidden": True},
                {"name": "Category",     "id": "category",    "editable": True},
                {"name": "Subcategory",  "id": "subcategory", "editable": True},
                {"name": "Price",        "id": "price",       "type": "numeric",  "editable": True},
                {"name": "Timestamp",    "id": "ts",          "type": "datetime", "editable": False},
            ],
            editable=True,
            page_size=20,
            filter_action="native",
            filter_options={"case": "insensitive"},
            sort_action="native",
            sort_mode="multi",
            style_table={"overflowX": "auto"},
            style_cell={"textAlign": "left"},
            style_cell_conditional=[
                {"if": {"column_id": "price"}, "textAlign": "right"},
                {"if": {"column_id": "ts"},    "textAlign": "right"},
            ],
        ),
        dcc.DatePickerSingle(id="date-picker", display_format="YYYY-MM-DD",
                             style={"marginTop": "1rem"}),
        html.Div(id="save-feedback", style={"marginTop": "1rem"}),
    ])


layout = serve_layout

# ──────────────────────────────────────────────────────────────
# Callback: update DatePicker when пользователь кликает на ячейку даты
# ──────────────────────────────────────────────────────────────
@callback(
    Output("date-picker", "date"),
    Input("purchases-table", "active_cell"),
    State("purchases-table", "data"),
    prevent_initial_call=True,
)
def sync_date_picker(active_cell, rows):
    if not active_cell or active_cell.get("column_id") != "date":
        # если выбрана не колонка даты – оставить тот же день
        return no_update
    row_index = active_cell["row"]
    return rows[row_index]["date"]


# ──────────────────────────────────────────────────────────────
# Callback: сохранение изменения даты через DatePicker
# ──────────────────────────────────────────────────────────────
@callback(
    Output("purchases-table", "data"),
    Output("save-feedback", "children"),
    Input("date-picker", "date"),
    State("purchases-table", "active_cell"),
    State("purchases-table", "data"),
    prevent_initial_call=True,
)
def save_date(new_date, active_cell, rows):
    if not active_cell or active_cell.get("column_id") != "date":
        return rows, no_update
    row_index = active_cell["row"]
    row = rows[row_index]

    old_date = row["date"]
    if old_date == new_date:
        return rows, no_update

    # обновляем локально
    rows[row_index]["date"] = new_date

    # сохраняем в БД
    purchase_id = row["id"]
    user_id = row["user_id"]
    update_user_purchase(user_id, purchase_id, {"date": new_date})

    return rows, f"Изменено: '{old_date}' ➡️ '{new_date}'"


# ──────────────────────────────────────────────────────────────
# Callback: автосохранение всех остальных полей (имя, сумма)
# ──────────────────────────────────────────────────────────────
@callback(
    Output("save-feedback", "children", allow_duplicate=True),
    Input("purchases-table", "data_timestamp"),
    State("purchases-table", "data"),
    State("purchases-table", "data_previous"),
    prevent_initial_call=True,
)
def autosave_changes(timestamp, current, previous):
    if previous is None:
        return no_update

    for new_row, old_row in zip(current, previous):
        # id обязателен
        purchase_id = new_row.get("id")
        user_id = new_row.get("user_id")
        if not purchase_id:
            continue

        # собираем отличия кроме даты (ей занимается DatePicker)
        changes = {
            k: v
            for k, v in new_row.items()
            if old_row.get(k) != v and k not in ("id", "user_id", "date")
        }
        if changes:
            # сохраняем первое изменение и прерываемся
            key, new_val = next(iter(changes.items()))
            old_val = old_row.get(key)
            update_user_purchase(user_id, purchase_id, {key: new_val})
            return f"Изменено: '{old_val}' ➡️ '{new_val}'"

    return no_update


